//! Autoinstall configuration for Ubuntu cloud-init.
//!
//! Generates bootloader configurations with autoinstall parameters.

use std::fs;
use std::io::Write;
use std::path::{Path, PathBuf};

use anyhow::{Context, Result};
use tracing::info;

/// Autoinstall configuration.
#[derive(Debug, Clone)]
pub struct AutoinstallConfig {
    /// URL for cloud-init datasource (e.g., "http://192.168.1.100:8080/").
    pub datasource_url: String,
    /// Path to user-data file (optional, for serving).
    pub user_data_path: Option<PathBuf>,
    /// Path to meta-data file (optional).
    pub meta_data_path: Option<PathBuf>,
}

impl AutoinstallConfig {
    /// Create a new autoinstall configuration.
    pub fn new(datasource_url: impl Into<String>) -> Self {
        Self {
            datasource_url: datasource_url.into(),
            user_data_path: None,
            meta_data_path: None,
        }
    }

    /// Set user-data file path.
    pub fn with_user_data(mut self, path: impl Into<PathBuf>) -> Self {
        self.user_data_path = Some(path.into());
        self
    }

    /// Set meta-data file path.
    pub fn with_meta_data(mut self, path: impl Into<PathBuf>) -> Self {
        self.meta_data_path = Some(path.into());
        self
    }

    /// Get kernel parameters for autoinstall.
    pub fn kernel_params(&self) -> String {
        format!(
            "autoinstall ds=nocloud-net;s={}",
            self.datasource_url
        )
    }
}

/// Bootloader configuration generator.
pub struct BootloaderConfigGenerator {
    /// TFTP root directory.
    tftp_root: PathBuf,
    /// Autoinstall configuration.
    autoinstall: Option<AutoinstallConfig>,
}

impl BootloaderConfigGenerator {
    /// Create a new bootloader config generator.
    pub fn new<P: AsRef<Path>>(tftp_root: P) -> Self {
        Self {
            tftp_root: tftp_root.as_ref().to_path_buf(),
            autoinstall: None,
        }
    }

    /// Set autoinstall configuration.
    pub fn with_autoinstall(mut self, config: AutoinstallConfig) -> Self {
        self.autoinstall = Some(config);
        self
    }

    /// Generate all bootloader configurations.
    pub fn generate(&self) -> Result<()> {
        self.generate_grub_config()?;
        self.generate_syslinux_config()?;
        Ok(())
    }

    /// Generate GRUB configuration for UEFI boot.
    pub fn generate_grub_config(&self) -> Result<()> {
        let grub_dir = self.tftp_root.join("grub");
        if !grub_dir.exists() {
            fs::create_dir_all(&grub_dir)
                .context("Failed to create grub directory")?;
        }

        let grub_cfg_path = grub_dir.join("grub.cfg");
        let config = self.grub_config_content();

        let mut file = fs::File::create(&grub_cfg_path)
            .with_context(|| format!("Failed to create {:?}", grub_cfg_path))?;
        file.write_all(config.as_bytes())?;

        info!("Generated GRUB config: {:?}", grub_cfg_path);
        Ok(())
    }

    /// Generate syslinux/pxelinux configuration for BIOS boot.
    pub fn generate_syslinux_config(&self) -> Result<()> {
        let pxe_dir = self.tftp_root.join("pxelinux.cfg");
        if !pxe_dir.exists() {
            fs::create_dir_all(&pxe_dir)
                .context("Failed to create pxelinux.cfg directory")?;
        }

        let default_path = pxe_dir.join("default");
        let config = self.syslinux_config_content();

        let mut file = fs::File::create(&default_path)
            .with_context(|| format!("Failed to create {:?}", default_path))?;
        file.write_all(config.as_bytes())?;

        info!("Generated syslinux config: {:?}", default_path);
        Ok(())
    }

    /// Generate GRUB configuration content.
    fn grub_config_content(&self) -> String {
        let extra_params = self.autoinstall
            .as_ref()
            .map(|a| format!(" {}", a.kernel_params()))
            .unwrap_or_default();

        format!(r#"# GRUB configuration generated by serabut
# Ubuntu autoinstall PXE boot

set default=0
set timeout=5

menuentry "Ubuntu Server Install{}" {{
    linux /casper/vmlinuz ip=dhcp{}
    initrd /casper/initrd
}}

menuentry "Ubuntu Server Install (Safe Mode)" {{
    linux /casper/vmlinuz ip=dhcp nomodeset{}
    initrd /casper/initrd
}}
"#,
            if self.autoinstall.is_some() { " (Autoinstall)" } else { "" },
            extra_params,
            extra_params,
        )
    }

    /// Generate syslinux configuration content.
    fn syslinux_config_content(&self) -> String {
        let extra_params = self.autoinstall
            .as_ref()
            .map(|a| format!(" {}", a.kernel_params()))
            .unwrap_or_default();

        format!(r#"# Syslinux configuration generated by serabut
# Ubuntu autoinstall PXE boot

DEFAULT install
TIMEOUT 50
PROMPT 1

LABEL install
    MENU LABEL Ubuntu Server Install{}
    KERNEL casper/vmlinuz
    APPEND initrd=casper/initrd ip=dhcp{}

LABEL install-safe
    MENU LABEL Ubuntu Server Install (Safe Mode)
    KERNEL casper/vmlinuz
    APPEND initrd=casper/initrd ip=dhcp nomodeset{}
"#,
            if self.autoinstall.is_some() { " (Autoinstall)" } else { "" },
            extra_params,
            extra_params,
        )
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_autoinstall_config_new() {
        let config = AutoinstallConfig::new("http://192.168.1.100:8080/");
        assert_eq!(config.datasource_url, "http://192.168.1.100:8080/");
        assert!(config.user_data_path.is_none());
    }

    #[test]
    fn test_autoinstall_config_with_user_data() {
        let config = AutoinstallConfig::new("http://test/")
            .with_user_data("/path/to/user-data");
        assert_eq!(config.user_data_path, Some(PathBuf::from("/path/to/user-data")));
    }

    #[test]
    fn test_autoinstall_kernel_params() {
        let config = AutoinstallConfig::new("http://192.168.1.100:8080/");
        let params = config.kernel_params();
        assert_eq!(params, "autoinstall ds=nocloud-net;s=http://192.168.1.100:8080/");
    }

    #[test]
    fn test_bootloader_generator_new() {
        let gen = BootloaderConfigGenerator::new("/tmp/tftp");
        assert_eq!(gen.tftp_root, PathBuf::from("/tmp/tftp"));
        assert!(gen.autoinstall.is_none());
    }

    #[test]
    fn test_bootloader_generator_with_autoinstall() {
        let config = AutoinstallConfig::new("http://test/");
        let gen = BootloaderConfigGenerator::new("/tmp/tftp")
            .with_autoinstall(config);
        assert!(gen.autoinstall.is_some());
    }

    #[test]
    fn test_grub_config_without_autoinstall() {
        let gen = BootloaderConfigGenerator::new("/tmp/tftp");
        let content = gen.grub_config_content();
        assert!(content.contains("menuentry"));
        assert!(content.contains("/casper/vmlinuz"));
        // Should not contain autoinstall kernel parameter
        assert!(!content.contains("ds=nocloud-net"));
    }

    #[test]
    fn test_grub_config_with_autoinstall() {
        let config = AutoinstallConfig::new("http://192.168.1.100:8080/");
        let gen = BootloaderConfigGenerator::new("/tmp/tftp")
            .with_autoinstall(config);
        let content = gen.grub_config_content();
        assert!(content.contains("autoinstall"));
        assert!(content.contains("ds=nocloud-net"));
        assert!(content.contains("http://192.168.1.100:8080/"));
    }

    #[test]
    fn test_syslinux_config_without_autoinstall() {
        let gen = BootloaderConfigGenerator::new("/tmp/tftp");
        let content = gen.syslinux_config_content();
        assert!(content.contains("LABEL install"));
        assert!(content.contains("casper/vmlinuz"));
        // Should not contain autoinstall kernel parameter
        assert!(!content.contains("ds=nocloud-net"));
    }

    #[test]
    fn test_syslinux_config_with_autoinstall() {
        let config = AutoinstallConfig::new("http://192.168.1.100:8080/");
        let gen = BootloaderConfigGenerator::new("/tmp/tftp")
            .with_autoinstall(config);
        let content = gen.syslinux_config_content();
        assert!(content.contains("autoinstall"));
        assert!(content.contains("ds=nocloud-net"));
        assert!(content.contains("http://192.168.1.100:8080/"));
    }
}
